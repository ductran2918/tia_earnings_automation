"""Database operations for public company metrics.

Handles storing extracted financial data to Supabase.
Currently supports:
- Grab Holdings (grab-com)
- Sea Group Limited (sea-group-garena)
- Alibaba Group Holding Limited (alibaba-group)
"""
from typing import Dict, Optional
from datetime import datetime

import streamlit as st

from supabase_client import supabase


def push_grab_to_supabase(extracted_data: Dict) -> Dict:
    """Push extracted Grab financial data to Supabase table.

    Args:
        extracted_data: Extracted metrics dict from grab_extraction.py
                       Must contain: company_slug, date, and metric fields

    Returns:
        Response dict with keys:
        - "success": bool - Whether push succeeded
        - "message": str - Success message
        - "record_id": int - Database record ID (if successful)
        - "error": str - Error message (if failed)
    """
    # Validation: Check if Supabase client is configured
    if not supabase:
        return {
            "success": False,
            "error": "Supabase not configured. Check SUPABASE_URL and SUPABSE_SERVICE_ROLE_KEY in .env file."
        }

    # Validation: Check for extraction errors
    if "error" in extracted_data:
        return {
            "success": False,
            "error": f"Cannot push extraction error: {extracted_data['error']}"
        }

    # Validation: Check required fields
    if not extracted_data.get("company_slug"):
        return {
            "success": False,
            "error": "Missing company_slug in extracted data"
        }

    if not extracted_data.get("date"):
        return {
            "success": False,
            "error": "Missing date in extracted data"
        }

    # Validation: Verify company_slug is grab-com
    if extracted_data.get("company_slug") != "grab-com":
        return {
            "success": False,
            "error": f"Invalid company_slug: {extracted_data.get('company_slug')}. Expected 'grab-com'"
        }

    # Validation: Verify date format (YYYY-MM-DD)
    try:
        datetime.fromisoformat(extracted_data["date"])
    except (ValueError, TypeError):
        return {
            "success": False,
            "error": f"Invalid date format: {extracted_data.get('date')}. Expected YYYY-MM-DD"
        }

    try:
        # Prepare data for insertion
        # Remove 'id' field as it's auto-generated by Supabase
        # Create a clean copy without the id field
        insert_data = {}
        for k, v in extracted_data.items():
            if k != "id":
                insert_data[k] = v

        # Debug: Log what we're about to insert (remove in production)
        if "id" in insert_data:
            st.warning(f"DEBUG: 'id' field still present in insert_data: {insert_data.get('id')}")
            # Force remove it
            del insert_data["id"]

        # Check if record already exists for this company_slug and date
        existing = check_duplicate_grab(
            extracted_data["company_slug"],
            extracted_data["date"]
        )

        if existing:
            # Record exists - UPDATE the existing record
            record_id = existing.get("id")

            # For UPDATE, also ensure no 'id' field is included
            update_data = {k: v for k, v in insert_data.items() if k != "id"}

            response = supabase.table("grab_metrics").update(
                update_data
            ).eq("id", record_id).execute()

            if response.data and len(response.data) > 0:
                updated_record = response.data[0]
                return {
                    "success": True,
                    "message": "Congratulations on successfully updating data in the database. Please wait 5 minutes for Flourish to update the charts automatically, then publish the article",
                    "record_id": updated_record.get("id"),
                    "data": updated_record
                }
        else:
            # Record doesn't exist - INSERT new record
            response = supabase.table("grab_metrics").insert(
                insert_data
            ).execute()

            if response.data and len(response.data) > 0:
                new_record = response.data[0]
                return {
                    "success": True,
                    "message": "Congratulations on successfully pushing data to the database. Please wait 5 minutes for Flourish to update the charts automatically, then publish the article",
                    "record_id": new_record.get("id"),
                    "data": new_record
                }

        # If we reach here, no data was returned
        return {
            "success": False,
            "error": "No data returned from Supabase after operation. Check table permissions."
        }

    except Exception as exc:
        # Catch all database errors (network, permissions, etc.)
        return {
            "success": False,
            "error": f"Supabase error: {str(exc)}"
        }


def check_duplicate_grab(company_slug: str, date: str) -> Optional[Dict]:
    """Check if Grab metrics already exist for given company and date.

    Args:
        company_slug: Company identifier (should be "grab-com")
        date: ISO date string (YYYY-MM-DD)

    Returns:
        Existing record dict if found, None otherwise
    """
    # Return None if Supabase not configured
    if not supabase:
        return None

    try:
        # Query for existing record with matching company_slug and date
        response = supabase.table("grab_metrics").select("*").eq(
            "company_slug", company_slug
        ).eq("date", date).execute()

        # Return first matching record if found
        if response.data and len(response.data) > 0:
            return response.data[0]

        return None

    except Exception:
        # Return None on any error (graceful degradation)
        return None


def get_all_grab_records(limit: int = 100) -> list:
    """Retrieve recent Grab metrics records from database.

    Args:
        limit: Maximum number of records to return (default: 100)

    Returns:
        List of record dicts, ordered by date descending
        Empty list if error or no data
    """
    # Return empty list if Supabase not configured
    if not supabase:
        return []

    try:
        # Query all Grab records, ordered by date (most recent first)
        response = supabase.table("grab_metrics").select("*").eq(
            "company_slug", "grab-com"
        ).order("date", desc=True).limit(limit).execute()

        if response.data:
            return response.data

        return []

    except Exception:
        # Return empty list on any error
        return []


def push_sea_group_to_supabase(extracted_data: Dict) -> Dict:
    """Push extracted Sea Group financial data to Supabase table.

    Args:
        extracted_data: Extracted metrics dict from sea_group_extraction.py
                       Must contain: company_slug, date, and metric fields

    Returns:
        Response dict with keys:
        - "success": bool - Whether push succeeded
        - "message": str - Success message
        - "record_id": int - Database record ID (if successful)
        - "error": str - Error message (if failed)
    """
    # Validation: Check if Supabase client is configured
    if not supabase:
        return {
            "success": False,
            "error": "Supabase not configured. Check SUPABASE_URL and SUPABSE_SERVICE_ROLE_KEY in .env file."
        }

    # Validation: Check for extraction errors
    if "error" in extracted_data:
        return {
            "success": False,
            "error": f"Cannot push extraction error: {extracted_data['error']}"
        }

    # Validation: Check required fields
    if not extracted_data.get("company_slug"):
        return {
            "success": False,
            "error": "Missing company_slug in extracted data"
        }

    if not extracted_data.get("date"):
        return {
            "success": False,
            "error": "Missing date in extracted data"
        }

    # Validation: Verify company_slug is sea-group-garena
    if extracted_data.get("company_slug") != "sea-group-garena":
        return {
            "success": False,
            "error": f"Invalid company_slug: {extracted_data.get('company_slug')}. Expected 'sea-group-garena'"
        }

    # Validation: Verify date format (YYYY-MM-DD)
    try:
        datetime.fromisoformat(extracted_data["date"])
    except (ValueError, TypeError):
        return {
            "success": False,
            "error": f"Invalid date format: {extracted_data.get('date')}. Expected YYYY-MM-DD"
        }

    try:
        # Prepare data for insertion
        # Remove 'id' field as it's auto-generated by Supabase
        # IMPORTANT: Explicitly exclude 'id' to avoid NOT-NULL constraint violation
        insert_data = {k: v for k, v in extracted_data.items() if k != "id"}

        # Double-check and force remove 'id' if it somehow still exists
        if "id" in insert_data:
            st.warning(f"DEBUG: 'id' field still present in insert_data: {insert_data.get('id')}")
            del insert_data["id"]

        # Check if record already exists for this company_slug and date
        existing = check_duplicate_sea_group(
            extracted_data["company_slug"],
            extracted_data["date"]
        )

        if existing:
            # Record exists - UPDATE the existing record
            record_id = existing.get("id")

            # For UPDATE, explicitly exclude 'id' field
            update_data = {k: v for k, v in insert_data.items() if k != "id"}

            response = supabase.table("seagroup_metrics").update(
                update_data
            ).eq("id", record_id).execute()

            if response.data and len(response.data) > 0:
                updated_record = response.data[0]
                return {
                    "success": True,
                    "message": "Congratulations on successfully updating data in the database. Please wait 5 minutes for Flourish to update the charts automatically, then publish the article",
                    "record_id": updated_record.get("id"),
                    "data": updated_record
                }
        else:
            # Record doesn't exist - INSERT new record
            response = supabase.table("seagroup_metrics").insert(
                insert_data
            ).execute()

            if response.data and len(response.data) > 0:
                new_record = response.data[0]
                return {
                    "success": True,
                    "message": "Congratulations on successfully pushing data to the database. Please wait 5 minutes for Flourish to update the charts automatically, then publish the article",
                    "record_id": new_record.get("id"),
                    "data": new_record
                }

        # If we reach here, no data was returned
        return {
            "success": False,
            "error": "No data returned from Supabase after operation. Check table permissions."
        }

    except Exception as exc:
        # Catch all database errors (network, permissions, etc.)
        return {
            "success": False,
            "error": f"Supabase error: {str(exc)}"
        }


def check_duplicate_sea_group(company_slug: str, date: str) -> Optional[Dict]:
    """Check if Sea Group metrics already exist for given company and date.

    Args:
        company_slug: Company identifier (should be "sea-group-garena")
        date: ISO date string (YYYY-MM-DD)

    Returns:
        Existing record dict if found, None otherwise
    """
    # Return None if Supabase not configured
    if not supabase:
        return None

    try:
        # Query for existing record with matching company_slug and date
        response = supabase.table("seagroup_metrics").select("*").eq(
            "company_slug", company_slug
        ).eq("date", date).execute()

        # Return first matching record if found
        if response.data and len(response.data) > 0:
            return response.data[0]

        return None

    except Exception:
        # Return None on any error (graceful degradation)
        return None


def get_all_sea_group_records(limit: int = 100) -> list:
    """Retrieve recent Sea Group metrics records from database.

    Args:
        limit: Maximum number of records to return (default: 100)

    Returns:
        List of record dicts, ordered by date descending
        Empty list if error or no data
    """
    # Return empty list if Supabase not configured
    if not supabase:
        return []

    try:
        # Query all Sea Group records, ordered by date (most recent first)
        response = supabase.table("seagroup_metrics").select("*").eq(
            "company_slug", "sea-group-garena"
        ).order("date", desc=True).limit(limit).execute()

        if response.data:
            return response.data

        return []

    except Exception:
        # Return empty list on any error
        return []


def push_alibaba_to_supabase(extracted_data: Dict) -> Dict:
    """Push extracted Alibaba Group financial data to Supabase table.

    Args:
        extracted_data: Extracted metrics dict from alibaba_extraction.py
                       Must contain: company_slug, date, and metric fields

    Returns:
        Response dict with keys:
        - "success": bool - Whether push succeeded
        - "message": str - Success message
        - "record_id": int - Database record ID (if successful)
        - "error": str - Error message (if failed)
    """
    # Validation: Check if Supabase client is configured
    if not supabase:
        return {
            "success": False,
            "error": "Supabase not configured. Check SUPABASE_URL and SUPABSE_SERVICE_ROLE_KEY in .env file."
        }

    # Validation: Check for extraction errors
    if "error" in extracted_data:
        return {
            "success": False,
            "error": f"Cannot push extraction error: {extracted_data['error']}"
        }

    # Validation: Check required fields
    if not extracted_data.get("company_slug"):
        return {
            "success": False,
            "error": "Missing company_slug in extracted data"
        }

    if not extracted_data.get("date"):
        return {
            "success": False,
            "error": "Missing date in extracted data"
        }

    # Validation: Verify company_slug is alibaba-group
    if extracted_data.get("company_slug") != "alibaba-group":
        return {
            "success": False,
            "error": f"Invalid company_slug: {extracted_data.get('company_slug')}. Expected 'alibaba-group'"
        }

    # Validation: Verify date format (YYYY-MM-DD)
    try:
        datetime.fromisoformat(extracted_data["date"])
    except (ValueError, TypeError):
        return {
            "success": False,
            "error": f"Invalid date format: {extracted_data.get('date')}. Expected YYYY-MM-DD"
        }

    try:
        # Prepare data for insertion
        # Remove 'id' field as it's auto-generated by Supabase
        # IMPORTANT: Explicitly exclude 'id' to avoid NOT-NULL constraint violation
        insert_data = {k: v for k, v in extracted_data.items() if k != "id"}

        # Double-check and force remove 'id' if it somehow still exists
        if "id" in insert_data:
            st.warning(f"DEBUG: 'id' field still present in insert_data: {insert_data.get('id')}")
            del insert_data["id"]

        # Check if record already exists for this company_slug and date
        existing = check_duplicate_alibaba(
            extracted_data["company_slug"],
            extracted_data["date"]
        )

        if existing:
            # Record exists - UPDATE the existing record
            record_id = existing.get("id")

            # For UPDATE, explicitly exclude 'id' field
            update_data = {k: v for k, v in insert_data.items() if k != "id"}

            response = supabase.table("alibaba_metrics").update(
                update_data
            ).eq("id", record_id).execute()

            if response.data and len(response.data) > 0:
                updated_record = response.data[0]
                return {
                    "success": True,
                    "message": "Congratulations on successfully updating data in the database. Please wait 5 minutes for Flourish to update the charts automatically, then publish the article",
                    "record_id": updated_record.get("id"),
                    "data": updated_record
                }
        else:
            # Record doesn't exist - INSERT new record
            response = supabase.table("alibaba_metrics").insert(
                insert_data
            ).execute()

            if response.data and len(response.data) > 0:
                new_record = response.data[0]
                return {
                    "success": True,
                    "message": "Congratulations on successfully pushing data to the database. Please wait 5 minutes for Flourish to update the charts automatically, then publish the article",
                    "record_id": new_record.get("id"),
                    "data": new_record
                }

        # If we reach here, no data was returned
        return {
            "success": False,
            "error": "No data returned from Supabase after operation. Check table permissions."
        }

    except Exception as exc:
        # Catch all database errors (network, permissions, etc.)
        return {
            "success": False,
            "error": f"Supabase error: {str(exc)}"
        }


def check_duplicate_alibaba(company_slug: str, date: str) -> Optional[Dict]:
    """Check if Alibaba Group metrics already exist for given company and date.

    Args:
        company_slug: Company identifier (should be "alibaba-group")
        date: ISO date string (YYYY-MM-DD)

    Returns:
        Existing record dict if found, None otherwise
    """
    # Return None if Supabase not configured
    if not supabase:
        return None

    try:
        # Query for existing record with matching company_slug and date
        response = supabase.table("alibaba_metrics").select("*").eq(
            "company_slug", company_slug
        ).eq("date", date).execute()

        # Return first matching record if found
        if response.data and len(response.data) > 0:
            return response.data[0]

        return None

    except Exception:
        # Return None on any error (graceful degradation)
        return None


def get_all_alibaba_records(limit: int = 100) -> list:
    """Retrieve recent Alibaba Group metrics records from database.

    Args:
        limit: Maximum number of records to return (default: 100)

    Returns:
        List of record dicts, ordered by date descending
        Empty list if error or no data
    """
    # Return empty list if Supabase not configured
    if not supabase:
        return []

    try:
        # Query all Alibaba Group records, ordered by date (most recent first)
        response = supabase.table("alibaba_metrics").select("*").eq(
            "company_slug", "alibaba-group"
        ).order("date", desc=True).limit(limit).execute()

        if response.data:
            return response.data

        return []

    except Exception:
        # Return empty list on any error
        return []

